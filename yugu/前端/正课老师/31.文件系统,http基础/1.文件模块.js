/*
文件系统属于nodejs原生自带的api,使用的过程中需要导入
才可以使用

fs:file system文件管理系统 提供了操作文档的功能(创建,删除,复制..)
但凡是模块都需要导入，可以直接导入也可以下载非官方的第三方模块
进行导入
require代表导入, 需要传入模块名称，可以传字符串，也可以传入路径

*/
var fs = require("fs");
// console.log(fs);
// 同步写入:writeFileSync
// 1.要写入文件的路径:(相对路径:相对于这个文件来说，路径的某一部分是不固定的
// 绝对路径:直接可以根据当前路径找到文件)
// 2.要写入的数据
// ./在当前文件所在路径下 :如果路径下面的文件不存在写入的时候
//  会先创建在写入，如果存在则代表刷新
// writeFileSync同步方法(要求在写入的过程中，其他程序要等待
// 文件写入完成之后才可以执行)
// fs.writeFileSync("./one.txt","ok");


// 方法与writeFileSync用法是一样的,都是写入文件
// 1.写入文件的路径
// 2.写入的文件内容
//3.回调函数:当任务完成之后，如果写入错误那么会把错误的信息返回
// var buffer =new Buffer();
// fs.writeFile("./123.txt", "路径一定不要写错",
// //  回调函数上面的error参数包含就是错误信息(路径拼错了,
// // 写入的数据不支持,将来网络请求的错误)
//     function (error) {
//         if (error) {
//             console.log(error);
//         } else {
//             console.log("成功");
//         }
//     });

    // fs.writeFileSync()同步
    // fs.writeFileAsync()异步
    /*
      同步:代码占用主线程，是阻塞的状态，直到任务结束之后才会
      打开现成
      异步:分线程:任务是在后台执行,不会阻塞当前代码，当前代码立刻
      可以执行，所以异步函数一般都会有一个回调的函数，当异步功能
      完毕之后回到主线程
      文件操作为什么会有异步?
      文件操作在写入的时候,耗时不确定,磁盘的写入速度，文件的大小等等
      都会影响到文件写入速度，如果使用同步容易造成堵塞，反映到程序
      上来说，出现的卡顿，在使用的时候尽量使用异步函数，避免这种
    */
    // 定时器也是一个异步函数

    // 读取文件:参数是文件的路径 返回的是文件里面的内容
    // var content =fs.readFileSync("./123.txt");
    // 默认返回的不是字符串而是原始的数据buffer
    // buffer是一个数据对象带有转换成字符串的方法
    // console.log(content.toString());

    // 异步读取
    // 第一个参数是路径，第二个是回调函数第一个参数错误信息
    // 第二个是数据
    fs.readFile("./123.txt",function(err,data){
        if (err) {
            console.log(err);
            
        } else {
            console.log(data.toString());
            
        }
    });
    // 同一个文件一定不要同时进行读和写  因为读比写走得快