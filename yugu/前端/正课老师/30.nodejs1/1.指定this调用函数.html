<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
</body>
<script>
    function f1(a,b){
        console.log(a+b);
        console.log(this);
    }
    // 函数方法被调用时，this代表的是调用当前函数的对象
    // 默认是window
    // f1(10,20);

    var people =new Object();
    people.age =30;
    // 函数本身也是对象，也可以调用自身的方法
    // call方法指定this调用对应的函数,第一个参数是指定的this
    // f1.call(people,1,2);
    // apply方法和call方法功能一样，只是后面的传参方式不同
    // f1.apply(people,[1,2]);
    // bind方法作用是返回一个新的函数，这个新函数的功能和原来的
    // 函数功能相同，但是该函数在执行的时候this是bind绑定的对象
    // var f2 =f1.bind("绑定的this");
    // console.log(f2);
    // 因为f2接收的是一个f1返回的新函数，所以可以调用
    // f2(10,20);
    // 构造函数
    function People(name,age){
        // people的对象可以调用才行
        this.work =function(){
            console.log("正在家中办公");
        }
        // 把当前的对象返回出去
        // 当前调用函数的对象
        return this;
    }
    // window对象调用的方法
    this.work =function(){
      console.log(this.age);
    }
    // this.work();
    var p =new People("xiabei",30);
    p.work();
    //this.work代表bind要"复制"的函数  赋值完成之后会返回给f3
    // 
    var f3 =this.work.bind(people);
    f3();
    /*
      this默认在html文档中指的是window
      this在单独的js文件中指的是、也是window对象
      当对象调用方法的时候在方法内部的this指的是当前的方法
      调用者
      实际的开发过程中可以通过call,apply,bind方法改变this
      的指向，但是一定要清楚每一次改变之后指针所指的位置
      
    */ 
    
</script>
</html>