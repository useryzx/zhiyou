<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>构造函数之间的继承</title>
</head>

<body>

    <script>

        // 可以通过call(), apply(), bind() 改变this的指向


        function Person(name, age, isMale, minzu) {
            // this 指向的Person
            this.name = name;
            this.age = age;
            this.isMale = isMale;
            this.minzu = minzu;
        }
        // 共享的属性和方法，需要挂载在原型上
        Person.prototype = {
            guoji: '中国',
            run: function () {
                console.log(this.name + '会长跑');
            }
        }


        function Man(name, age, minzu) {
            // this指向的是当前的构造函数Man
            console.log(this);

            // func.call(thisArg, arg1, arg2, arg3, ...)
            // 通过call方法，调用func函数，func函数在执行时，其内部原有的this指向会被替换成传入的this指向
            // thisArg: 最新的this指向，即当前func函数运行环境中的this指向
            // arg1, arg2, arg3..要传入的参数列表

            //        Person.call(this, name, age, null,  minzu);

            //        func.apply(thisArg, [arg1, arg2, arg3, ...])

            //        Person.apply(this, [name, age, null, minzu]);

            //   func.bind(thisArg, arg1, arg2, arg3, ...)
            // bind方法是创建一个新函数(代码保持一致)，在新函数执行过程中，改变this指向
            Person.bind(this, name, age, true, minzu)();

            //        Person(name, age, null, minzu);


        }
        var m1 = new Man('大白', 19, '汉族');
        console.log(m1);
        //    console.log( m1.guoji );
        //    m1.run();

        // call() 只解决了构造函数模板内容的继承，放置在原型中的数据，没有被继承下来

        // 原型链2条
        // person实例 --> Person的原型(guoji, run)  -- function  的原型  --- Object
        //m1 --> Man的原型  -- function   的原型  --- Object
        // m2 ----> Man 的原型 ---> person实例化数据  ---- Object
        // 改变原型的指向
        Man.prototype = new Person();
        var m2 = new Man('二白', 21, '汉族');
        m2.run();


    // 构造函数之间的继承
    // 1. 模板数据之间的继承
    // 2. 原型中的数据的继承


    </script>
</body>

</html>