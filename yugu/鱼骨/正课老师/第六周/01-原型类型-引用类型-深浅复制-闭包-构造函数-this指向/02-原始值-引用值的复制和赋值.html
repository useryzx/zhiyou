<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>原始值和引用值的复制和赋值</title>
</head>
<body>

<script>
    // 原始值在复制过程中，传递的是值本身
    var str1 = 'abc';    // 赋值
    var str2 = str1;   // 复制
    str1 = 'aaa';  // 再赋值
    console.log( str2 );

    // 引用值在复制过程中，传递的是指针方向，指向的是存储在内存中的同一个数据
    // 只要有一个有操作处理，都会影响数据本身
    var arr1 = [];
    var arr2 = arr1;
    arr1.push(11);
    console.log( arr2 );

    // 数组的复制
    var arr1 = [1,true, 'zifu', 15];
    // 问题：复制过程中，在处理数据时，互不影响
    var arr2 = [];
    for( var i = 0; i < arr1.length; i++ ){
        arr2.push( arr1[i] );
    }
    console.log( arr2 );
    arr1.push(100);
    console.log( arr1 );
    console.log( arr2 );

    // 对象的复制 ： 对象，被称为关联数组
    var obj1 = {
        name:'张三',
        age:19,
        isMale:true
    }
    var obj2 = {};
    for( var key in obj1 ){
        obj2[key] = obj1[key];
    }
    console.log( obj2 );
    obj1.isMale = false;
    console.log( obj2 );

    var arr3 = [];
    for( var ins in arr1 ){
//        console.log( ins );
        arr3[ins] = arr1[ins];
    }

    // 问题：需要知道复制的是数组还是对象
    console.log( typeof arr1);  // object
    console.log( typeof obj1 );  // object

    // instanceof 判断前者是否是后者的具体实例，即判断是否是数组
    console.log( arr1 instanceof Array );   //  true
    console.log( obj1 instanceof Array );   // false

    // 方法封装 : 处理的是值全部都是原始类型   --- 浅复制
    function copy( oldObj ){

        var newObj = ( oldObj instanceof Array ) ?  [] : {};

        for( var ins in oldObj ){
            newObj[ins] = oldObj[ins];
        }
        return newObj;
    }

    // 问题：值如果有引用类型呢  --- 深复制
    var arr4 = [1, 2, 3, [15, 20, 22]];
    var arr5 = copy(arr4);
    arr4[3].push( 'zifu' );
    console.log( arr5 );




</script>

</body>
</html>